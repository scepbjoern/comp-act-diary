// =============================================================================
// COMP-ACT-DIARY - Finales Prisma Schema (Dokumentiert)
// =============================================================================
// Basierend auf: docs/data-model-architecture.md
// Erstellt: Dezember 2024
// 
// Dieses Schema enth√§lt vollst√§ndige Dokumentation aller Attribute.
// Prisma-Kommentare mit /// werden in die generierte Dokumentation √ºbernommen.
// =============================================================================

generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "debian-openssl-3.0.x", "linux-musl-openssl-3.0.x"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// =============================================================================
// ENUMS
// =============================================================================

/// Typ einer Kern-Entit√§t f√ºr die Entity-Registry (Polymorphie)
enum EntityType {
  JOURNAL_ENTRY       /// Tagebucheintrag
  CONTACT             /// Kontakt/Person
  LOCATION            /// Ort
  MEDIA_ASSET         /// Mediendatei (Foto, Audio, Video)
  MEASUREMENT         /// Messwert (Symptom, Metrik)
  ACT_VALUE           /// ACT-Wert
  ACT_GOAL            /// ACT-Ziel
  HABIT               /// Gewohnheit
  CALENDAR_EVENT      /// Kalendereintrag
  CONSUMPTION         /// Medienkonsum (Musik, Film, Buch)
  INVENTORY_ITEM      /// Inventar-Gegenstand
  TIME_TRACKING_ENTRY /// Zeiterfassungseintrag
  BOOKMARK            /// Lesezeichen
}

/// Art eines Zeitraums
enum TimeBoxKind {
  DAY    /// Ein einzelner Tag
  WEEK   /// Eine Kalenderwoche
  MONTH  /// Ein Kalendermonat
  YEAR   /// Ein Kalenderjahr
  CUSTOM /// Benutzerdefinierter Zeitraum (z.B. Reise, Projekt, Kur-Phase)
}

/// Art einer Taxonomie-Einheit
enum TaxonomyKind {
  CATEGORY      /// Hierarchische Kategorie (z.B. "Arbeit > Meetings")
  TAG           /// Flaches Schlagwort
  EMOTION       /// Emotion/Gef√ºhl (z.B. "Freude", "Angst")
  TOPIC         /// Thema (z.B. "Gesundheit", "Familie")
  TRAIT         /// Pers√∂nlichkeitsmerkmal
  LIFE_AREA     /// Lebensbereich f√ºr ACT-Werte
  CONTACT_GROUP /// Google Contact Group / Kontakt-Label
}

/// Herkunft einer Taxonomie
enum TaxonomyOrigin {
  SYSTEM /// Vom System vordefiniert (z.B. Standard-Emotionen)
  USER   /// Vom Benutzer erstellt
  IMPORT /// Aus externem System importiert
  AI     /// Von KI vorgeschlagen
}

/// Quelle eines Taggings
enum TaggingSource {
  USER   /// Manuell vom Benutzer vergeben
  AI     /// Von KI automatisch vergeben
  IMPORT /// Aus Import √ºbernommen
}

/// Status eines ACT-Ziels
enum GoalStatus {
  ACTIVE    /// Aktiv verfolgt
  PAUSED    /// Pausiert
  ACHIEVED  /// Erfolgreich erreicht
  ABANDONED /// Aufgegeben
}

/// Status eines Habit-CheckIns
enum CheckInStatus {
  DONE    /// Vollst√§ndig erledigt
  PARTIAL /// Teilweise erledigt
  SKIPPED /// Bewusst √ºbersprungen
}

/// Status einer Belohnung
enum RewardStatus {
  PENDING /// Noch nicht verdient
  EARNED  /// Verdient, aber noch nicht eingel√∂st
  CLAIMED /// Eingel√∂st
}

/// Status eines Inventar-Gegenstands
enum InventoryStatus {
  IN_POSSESSION /// Im Besitz
  SOLD          /// Verkauft
  GIFTED        /// Verschenkt
}

/// Rolle eines Medien-Anhangs
enum MediaRole {
  COVER      /// Titelbild/Hauptbild
  GALLERY    /// Teil einer Galerie
  ATTACHMENT /// Allgemeiner Anhang
  THUMBNAIL  /// Vorschaubild
}

/// Art des Medienkonsums
enum ConsumptionKind {
  MUSIC   /// Musik (Song, Album)
  MOVIE   /// Film
  BOOK    /// Buch
  PODCAST /// Podcast-Episode
  GAME    /// Videospiel
  ARTICLE /// Artikel/Blogpost
  VIDEO   /// Video (YouTube, etc.)
}

/// Datentyp einer Metrik
enum MetricDataType {
  NUMERIC /// Zahlenwert (z.B. Gewicht in kg)
  TEXT    /// Freitext
  BOOLEAN /// Ja/Nein
  SCALE   /// Skala (z.B. 1-10)
}

/// Quelle einer Messung
enum MeasurementSource {
  MANUAL /// Manuell eingegeben
  IMPORT /// Aus Import
  DEVICE /// Von Ger√§t (z.B. Smartwatch)
}

/// Status eines Sync-Laufs
enum SyncStatus {
  PENDING   /// Geplant/Wartend
  RUNNING   /// L√§uft gerade
  COMPLETED /// Erfolgreich abgeschlossen
  FAILED    /// Fehlgeschlagen
}

/// Typ eines Sync-Providers
enum SyncProviderType {
  PHOTOPRISM       /// Photoprism Fotoverwaltung
  SAMSUNG_GALLERY  /// Samsung Gallery
  TOGGL            /// Toggl Zeiterfassung
  GOOGLE_CALENDAR  /// Google Kalender
  APPLE_CALENDAR   /// Apple Kalender
  SPOTIFY          /// Spotify Musikstreaming
  LAST_FM          /// Last.fm Scrobbling
  GOOGLE_CONTACTS  /// Google Contacts
}

/// Art einer Interaktion mit einem Kontakt
enum InteractionKind {
  GENERAL   /// Allgemeine Erw√§hnung/Bezug (z.B. Import)
  CALL      /// Telefonat
  VIDEO     /// Videoanruf
  MEETING   /// Pers√∂nliches Treffen
  MESSAGE   /// Textnachricht (SMS, Chat)
  EMAIL     /// E-Mail
  LETTER    /// Brief
  SOCIAL    /// Social Media Interaktion
  MENTION   /// Erw√§hnung in Journal-Eintrag
}

/// Status einer Aufgabe
enum TaskStatus {
  PENDING   /// Offen
  COMPLETED /// Erledigt
  CANCELLED /// Abgebrochen
}

/// Typ einer Benachrichtigung
enum NotificationType {
  GENERAL              /// Allgemeine Benachrichtigung
  BIRTHDAY_REMINDER    /// Geburtstagserinnerung
  SYNC_CONFLICT        /// Konflikt bei Synchronisation
  SYNC_ERROR           /// Fehler bei Synchronisation
  CONTACT_MATCH_REQUIRED /// Manuelle Zuordnung erforderlich
}

/// Art eines POI (Point of Interest)
enum PoiType {
  HOME       /// Zuhause
  WORK       /// Arbeitsplatz
  RESTAURANT /// Restaurant/Caf√©
  SHOP       /// Gesch√§ft
  LANDMARK   /// Sehensw√ºrdigkeit
  TRANSPORT  /// Verkehrsmittel (Bahnhof, Flughafen)
  NATURE     /// Natur (Park, Wald, See)
  SPORT      /// Sportst√§tte
  HEALTH     /// Gesundheit (Arzt, Krankenhaus)
  OTHER      /// Sonstiges
}

// =============================================================================
// KERN-SYSTEM
// =============================================================================

/// Benutzer der Anwendung
model User {
  /// Eindeutige ID (UUID)
  id              String   @id @default(uuid())
  /// Benutzername f√ºr Login (eindeutig)
  username        String   @unique
  /// Anzeigename (optional, z.B. "Max Mustermann")
  displayName     String?
  /// E-Mail-Adresse (optional)
  email           String?
  /// Gehashtes Passwort (bcrypt)
  passwordHash    String
  /// URL zum Profilbild (optional)
  profileImageUrl String?
  /// Benutzereinstellungen als JSON (Theme, Zeitformat, KI-Modelle, etc.)
  settings        Json?
  /// Erstellungszeitpunkt
  createdAt       DateTime @default(now())
  /// Letztes Update
  updatedAt       DateTime @updatedAt

  // Relationen
  entities              Entity[]
  timeBoxes             TimeBox[]
  dayEntries            DayEntry[]
  journalEntryTypes     JournalEntryType[]
  journalTemplates      JournalTemplate[]
  journalEntries        JournalEntry[]
  actValues             ActValue[]
  actGoals              ActGoal[]
  habits                Habit[]
  habitCheckIns         HabitCheckIn[]
  rewards               Reward[]
  exerciseDefinitions   ExerciseDefinition[]
  exerciseSessions      ExerciseSession[]
  taxonomies            Taxonomy[]
  taggings              Tagging[]
  contacts              Contact[]
  personRelations       PersonRelation[]
  interactions          Interaction[]
  locations             Location[]
  locationVisits        LocationVisit[]
  mediaAssets           MediaAsset[]
  mediaAttachments      MediaAttachment[]
  metricDefinitions     MetricDefinition[]
  measurements          Measurement[]
  syncProviders         SyncProvider[]
  externalSyncs         ExternalSync[]
  timeTrackingEntries   TimeTrackingEntry[]
  calendarEvents        CalendarEvent[]
  consumptions          Consumption[]
  inventoryItems        InventoryItem[]
  bookmarks             Bookmark[]
  entityLinks           EntityLink[]
  embeddings            Embedding[]
  entryTimeBoxes        EntryTimeBox[]
  trashItems            Trash[]
  chatMethods           ChatMethod[]
  improvementPrompts    ImprovementPrompt[]
  llmModels             LlmModel[]
  tasks                 Task[]
  notifications         Notification[]
}

/// Entity-Registry: Zentrale Tabelle f√ºr FK-basierte Polymorphie.
/// Jede Kern-Entit√§t (JournalEntry, Contact, etc.) teilt ihre ID mit einem Entity-Eintrag.
/// Polymorphe Tabellen (Tagging, MediaAttachment, etc.) referenzieren Entity.id als echten FK.
model Entity {
  /// ID (identisch mit der ID der spezifischen Entit√§t, z.B. JournalEntry.id)
  id        String     @id @default(uuid())
  /// Besitzer-User
  userId    String
  /// Typ der Entit√§t (bestimmt, welche spezifische Tabelle die Details enth√§lt)
  type      EntityType
  /// Erstellungszeitpunkt
  createdAt DateTime   @default(now())
  /// Letztes Update
  updatedAt DateTime   @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Polymorphe Relationen
  taggings         Tagging[]
  mediaAttachments MediaAttachment[]
  entityLinksFrom  EntityLink[]      @relation("EntityLinkSource")
  entityLinksTo    EntityLink[]      @relation("EntityLinkTarget")
  externalSyncs    ExternalSync[]
  embeddings       Embedding[]
  entryTimeBoxes   EntryTimeBox[]

  @@index([userId, type])
  @@index([type])
}

// =============================================================================
// ZEITMODELL
// =============================================================================

/// Zeitraum: Generisches Konzept f√ºr Tage, Wochen, Monate, Jahre oder benutzerdefinierte Perioden.
/// Erm√∂glicht hierarchische Strukturen (z.B. Wochen geh√∂ren zu Monaten).
model TimeBox {
  /// Eindeutige ID
  id        String      @id @default(uuid())
  /// Besitzer-User
  userId    String
  /// Art des Zeitraums (DAY, WEEK, MONTH, YEAR, CUSTOM)
  kind      TimeBoxKind
  /// Beginn des Zeitraums (inklusiv)
  startAt   DateTime
  /// Ende des Zeitraums (exklusiv)
  endAt     DateTime
  /// Zeitzone (z.B. "Europe/Zurich") - wichtig f√ºr korrekte Tagesberechnung
  timezone  String      @default("Europe/Zurich")
  /// Lokales Datum im Format YYYY-MM-DD (nur f√ºr kind=DAY, z.B. "2024-12-13")
  localDate String?
  /// Titel (optional, z.B. "Sommerurlaub 2024" f√ºr CUSTOM)
  title     String?
  /// √úbergeordneter Zeitraum (z.B. Woche f√ºr einen Tag, Monat f√ºr eine Woche)
  parentId  String?
  /// Erstellungszeitpunkt
  createdAt DateTime    @default(now())
  /// Letztes Update
  updatedAt DateTime    @updatedAt

  user     User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  parent   TimeBox?  @relation("TimeBoxHierarchy", fields: [parentId], references: [id])
  children TimeBox[] @relation("TimeBoxHierarchy")

  // Relationen
  dayEntry            DayEntry?
  journalEntries      JournalEntry[]
  habitCheckIns       HabitCheckIn[]
  exerciseSessions    ExerciseSession[]
  interactions        Interaction[]
  mediaAttachments    MediaAttachment[]
  measurements        Measurement[]
  timeTrackingEntries TimeTrackingEntry[]
  calendarEvents      CalendarEvent[]
  consumptions        Consumption[]
  entryTimeBoxes      EntryTimeBox[]
  locationVisits      LocationVisit[]

  /// Pro User und Tag nur eine DAY-TimeBox
  @@unique([userId, kind, localDate])
  @@index([userId, kind, startAt])
  @@index([parentId])
}

/// Tageseintrag: Spezifische Daten f√ºr einen einzelnen Tag.
/// 1:1-Beziehung zu einer TimeBox mit kind=DAY.
/// Enth√§lt tagesspezifische Aggregat-Daten wie Bewertung und KI-Zusammenfassung.
model DayEntry {
  /// Eindeutige ID
  id        String   @id @default(uuid())
  /// Besitzer-User
  userId    String
  /// Referenz auf die zugeh√∂rige DAY-TimeBox (1:1)
  timeBoxId String?  @unique
  /// Tagesbewertung (1-10, optional)
  dayRating Int?
  /// KI-generierte Zusammenfassung des Tages (Markdown)
  aiSummary String?
  /// Wetterdaten als JSON (optional, z.B. {temp: 22, condition: "sunny"})
  weather   Json?
  /// Erstellungszeitpunkt
  createdAt DateTime @default(now())
  /// Letztes Update
  updatedAt DateTime @updatedAt

  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  timeBox TimeBox? @relation(fields: [timeBoxId], references: [id], onDelete: Cascade)

  @@index([userId])
}

/// Verkn√ºpfung zwischen Entit√§ten und Zeitr√§umen (M:N).
/// Erm√∂glicht die Zuordnung einer Entit√§t zu mehreren Zeitr√§umen.
/// Beispiel: Ein Foto kann sowohl einem Tag als auch einem Reisejournal zugeordnet sein.
model EntryTimeBox {
  /// Eindeutige ID
  id        String  @id @default(uuid())
  /// Referenz auf die Entit√§t (via Entity-Registry)
  entityId  String
  /// Besitzer-User (f√ºr Multi-Tenant-Queries)
  userId    String
  /// Referenz auf den Zeitraum
  timeBoxId String
  /// Ist dies die prim√§re Zeitraum-Zuordnung?
  isPrimary Boolean @default(false)
  /// Erstellungszeitpunkt
  createdAt DateTime @default(now())

  entity  Entity  @relation(fields: [entityId], references: [id], onDelete: Cascade)
  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  timeBox TimeBox @relation(fields: [timeBoxId], references: [id], onDelete: Cascade)

  @@unique([entityId, timeBoxId])
  @@index([userId, timeBoxId])
  @@index([entityId])
}

// =============================================================================
// JOURNAL
// =============================================================================

/// Typ eines Tagebucheintrags (z.B. "Tagesnotiz", "Mahlzeit", "Reflexion").
/// Als Entit√§t statt Enum, um neue Typen ohne Migration hinzuf√ºgen zu k√∂nnen.
model JournalEntryType {
  /// Eindeutige ID
  id                String   @id @default(uuid())
  /// User-ID (NULL = System-definierter Typ, verf√ºgbar f√ºr alle User)
  userId            String?
  /// Eindeutiger Code (z.B. "meal", "daily_reflection", "diary")
  code              String
  /// Anzeigename (z.B. "Mahlzeit")
  name              String
  /// Beschreibung (optional)
  description       String?
  /// Icon (Emoji oder Icon-Name, z.B. "üçΩÔ∏è")
  icon              String?
  /// Standard-Template f√ºr diesen Typ
  defaultTemplateId String?
  /// Sortierreihenfolge in der UI
  sortOrder         Int      @default(0)
  /// Erstellungszeitpunkt
  createdAt         DateTime @default(now())
  /// Letztes Update
  updatedAt         DateTime @updatedAt

  user            User?            @relation(fields: [userId], references: [id], onDelete: Cascade)
  defaultTemplate JournalTemplate? @relation("DefaultTemplate", fields: [defaultTemplateId], references: [id])
  journalEntries  JournalEntry[]

  @@unique([userId, code])
  @@index([userId, sortOrder])
}

/// Vorlage f√ºr strukturierte Tagebucheintr√§ge.
/// Enth√§lt Prompts/Fragen, die den Benutzer beim Schreiben leiten.
model JournalTemplate {
  /// Eindeutige ID
  id          String         @id @default(uuid())
  /// User-ID (NULL = System-definiertes Template)
  userId      String?
  /// Name des Templates (z.B. "Morgenreflexion")
  name        String
  /// Beschreibung (optional)
  description String?
  /// Prompts/Fragen als JSON-Array (z.B. ["Was war heute gut?", "Wof√ºr bist du dankbar?"])
  prompts     Json?
  /// Herkunft (SYSTEM, USER, AI)
  origin      TaxonomyOrigin @default(USER)
  /// Erstellungszeitpunkt
  createdAt   DateTime       @default(now())
  /// Letztes Update
  updatedAt   DateTime       @updatedAt

  user            User?              @relation(fields: [userId], references: [id], onDelete: Cascade)
  journalEntries  JournalEntry[]
  defaultForTypes JournalEntryType[] @relation("DefaultTemplate")

  @@index([userId])
}

/// Tagebucheintrag: Kern-Entit√§t f√ºr alle Arten von Journal-Eintr√§gen.
/// Kann Tagesnotizen, Mahlzeiten, Reflexionen, etc. sein (bestimmt durch typeId).
model JournalEntry {
  /// Eindeutige ID (= Entity.id f√ºr Polymorphie)
  id          String    @id @default(uuid())
  /// Besitzer-User
  userId      String
  /// Typ des Eintrags (Referenz auf JournalEntryType)
  typeId      String
  /// Verwendetes Template (optional)
  templateId  String?
  /// Zeitraum, zu dem der Eintrag geh√∂rt (DAY f√ºr Tagesnotiz, WEEK f√ºr Wochenreflexion, etc.)
  timeBoxId   String
  /// Ort, an dem der Eintrag erstellt wurde (optional)
  locationId  String?
  /// Titel (optional)
  title       String?
  /// Inhalt (Markdown) - bei Audio-Eintr√§gen das verbesserte Transkript
  content     String
  /// Original-Transkript (unbearbeitet, direkt von Speech-to-Text)
  originalTranscript String?
  /// KI-generierte Zusammenfassung (optional)
  aiSummary   String?
  /// KI-generierte Analyse/Interpretation (z.B. ACT-Perspektive)
  analysis    String?
  /// Zeitstempel der letzten Content-√Ñnderung (f√ºr "veraltet"-Warnung bei analysis/aiSummary)
  contentUpdatedAt DateTime?
  /// Enth√§lt sensible Daten? (f√ºr Verschl√ºsselung/biometrischen Schutz)
  isSensitive Boolean   @default(false)
  /// Soft-Delete Zeitpunkt (NULL = nicht gel√∂scht)
  deletedAt   DateTime?
  /// Erstellungszeitpunkt
  createdAt   DateTime  @default(now())
  /// Letztes Update
  updatedAt   DateTime  @updatedAt

  user     User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  type     JournalEntryType @relation(fields: [typeId], references: [id])
  template JournalTemplate? @relation(fields: [templateId], references: [id])
  timeBox  TimeBox          @relation(fields: [timeBoxId], references: [id])
  location Location?        @relation(fields: [locationId], references: [id])

  exerciseSessions ExerciseSession[]
  locationVisits   LocationVisit[]
  interactions     Interaction[]

  @@index([userId, typeId])
  @@index([timeBoxId])
  @@index([locationId])
  @@index([deletedAt])
}

// =============================================================================
// ACT-DOM√ÑNE (Acceptance and Commitment Therapy)
// =============================================================================

/// ACT-Wert: Was ist mir wirklich wichtig im Leben?
/// Werte sind dauerhafte Richtungen, keine erreichbaren Ziele.
/// Unterst√ºtzt Versionierung via validFrom/validTo.
model ActValue {
  /// Eindeutige ID (= Entity.id)
  id             String    @id @default(uuid())
  /// Besitzer-User
  userId         String
  /// URL-freundlicher Slug (z.B. "family", "health")
  slug           String
  /// Titel (z.B. "Familie", "Gesundheit")
  title          String
  /// Beschreibung (optional, Markdown)
  description    String?
  /// Icon (Emoji oder Icon-Name)
  icon           String?
  /// Bild-URL (optional)
  imageUrl       String?
  /// Lebensbereich (z.B. "relationships", "career")
  lifeArea       String?
  /// Wichtigkeits-Rang (1 = wichtigster Wert)
  importanceRank Int?
  /// G√ºltig ab (f√ºr Versionierung)
  validFrom      DateTime  @default(now())
  /// G√ºltig bis (NULL = aktuell g√ºltig)
  validTo        DateTime?
  /// Erstellungszeitpunkt
  createdAt      DateTime  @default(now())
  /// Letztes Update
  updatedAt      DateTime  @updatedAt

  user  User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  goals ActGoal[]

  @@unique([userId, slug])
  @@index([userId, validFrom])
}

/// ACT-Ziel: Konkretes, messbares Ziel, das einem Wert dient.
/// Im Gegensatz zu Werten sind Ziele erreichbar.
model ActGoal {
  /// Eindeutige ID (= Entity.id)
  id          String     @id @default(uuid())
  /// Besitzer-User
  userId      String
  /// Zugeh√∂riger Wert (optional, da Ziele auch unabh√§ngig sein k√∂nnen)
  valueId     String?
  /// URL-freundlicher Slug
  slug        String
  /// Titel (z.B. "10km laufen k√∂nnen")
  title       String
  /// Beschreibung (optional, Markdown)
  description String?
  /// Icon
  icon        String?
  /// Bild-URL
  imageUrl    String?
  /// Zieldatum (optional)
  targetDate  DateTime?
  /// Fortschritt in Prozent (0-100)
  progress    Int        @default(0)
  /// Status (ACTIVE, PAUSED, ACHIEVED, ABANDONED)
  status      GoalStatus @default(ACTIVE)
  /// G√ºltig ab (f√ºr Versionierung)
  validFrom   DateTime   @default(now())
  /// G√ºltig bis (NULL = aktuell g√ºltig)
  validTo     DateTime?
  /// Erstellungszeitpunkt
  createdAt   DateTime   @default(now())
  /// Letztes Update
  updatedAt   DateTime   @updatedAt

  user    User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  value   ActValue? @relation(fields: [valueId], references: [id])
  habits  Habit[]
  rewards Reward[]

  @@unique([userId, slug])
  @@index([userId, status])
  @@index([valueId])
}

/// Gewohnheit: Wiederkehrende Aktivit√§t zur Zielerreichung.
model Habit {
  /// Eindeutige ID (= Entity.id)
  id          String    @id @default(uuid())
  /// Besitzer-User
  userId      String
  /// Zugeh√∂riges Ziel (optional)
  goalId      String?
  /// URL-freundlicher Slug
  slug        String
  /// Titel (z.B. "T√§glich 30 Min laufen")
  title       String
  /// Beschreibung (optional)
  description String?
  /// Icon
  icon        String?
  /// H√§ufigkeit als String (z.B. "daily", "3x_week", "weekdays")
  frequency   String?
  /// Aktuelle Streak-L√§nge (Cache, berechnet aus CheckIns)
  streakCount Int       @default(0)
  /// Letzter CheckIn-Zeitpunkt (Cache)
  lastCheckIn DateTime?
  /// Ist die Gewohnheit aktiv?
  isActive    Boolean   @default(true)
  /// Sortierreihenfolge in der UI
  sortOrder   Int       @default(0)
  /// Erstellungszeitpunkt
  createdAt   DateTime  @default(now())
  /// Letztes Update
  updatedAt   DateTime  @updatedAt

  user     User           @relation(fields: [userId], references: [id], onDelete: Cascade)
  goal     ActGoal?       @relation(fields: [goalId], references: [id])
  checkIns HabitCheckIn[]
  rewards  Reward[]

  @@unique([userId, slug])
  @@index([userId, isActive])
  @@index([goalId])
}

/// Habit-CheckIn: Erfasst, ob eine Gewohnheit an einem Tag erf√ºllt wurde.
/// Erm√∂glicht Historisierung und Analyse von Gewohnheiten.
model HabitCheckIn {
  /// Eindeutige ID
  id         String        @id @default(uuid())
  /// Zugeh√∂rige Gewohnheit
  habitId    String
  /// Besitzer-User (f√ºr Multi-Tenant-Queries)
  userId     String
  /// Zeitraum (typischerweise DAY-TimeBox)
  timeBoxId  String
  /// Status (DONE, PARTIAL, SKIPPED)
  status     CheckInStatus @default(DONE)
  /// Notizen (optional)
  notes      String?
  /// Zeitpunkt der Erf√ºllung
  occurredAt DateTime      @default(now())
  /// Erstellungszeitpunkt
  createdAt  DateTime      @default(now())

  habit   Habit   @relation(fields: [habitId], references: [id], onDelete: Cascade)
  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  timeBox TimeBox @relation(fields: [timeBoxId], references: [id])

  /// Pro Habit pro Tag nur ein CheckIn
  @@unique([habitId, timeBoxId])
  @@index([userId, occurredAt])
}

/// Belohnung: Selbst-Belohnung f√ºr Zielerreichung oder Streak-Meilensteine.
model Reward {
  /// Eindeutige ID
  id             String       @id @default(uuid())
  /// Besitzer-User
  userId         String
  /// Zugeh√∂riges Ziel (optional, f√ºr Goal-Belohnungen)
  goalId         String?
  /// Zugeh√∂rige Gewohnheit (optional, f√ºr Streak-Belohnungen)
  habitId        String?
  /// Titel (z.B. "Neues Buch kaufen")
  title          String
  /// Beschreibung (optional)
  description    String?
  /// Ben√∂tigte Punkte/Tage (z.B. 30 f√ºr "30-Tage-Streak")
  pointsRequired Int?
  /// Status (PENDING, EARNED, CLAIMED)
  status         RewardStatus @default(PENDING)
  /// Zeitpunkt, wann verdient
  earnedAt       DateTime?
  /// Zeitpunkt, wann eingel√∂st
  claimedAt      DateTime?
  /// Erstellungszeitpunkt
  createdAt      DateTime     @default(now())
  /// Letztes Update
  updatedAt      DateTime     @updatedAt

  user  User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  goal  ActGoal? @relation(fields: [goalId], references: [id])
  habit Habit?   @relation(fields: [habitId], references: [id])

  @@index([userId, status])
}

// =============================================================================
// EXERCISES (ACT-√úbungen, Mindfulness, etc.)
// =============================================================================

/// √úbungs-Definition: Vorlage f√ºr eine strukturierte √úbung.
/// Kann System-definiert (z.B. ACT-√úbungen) oder User-definiert sein.
model ExerciseDefinition {
  /// Eindeutige ID
  id          String         @id @default(uuid())
  /// User-ID (NULL = System-definierte √úbung)
  userId      String?
  /// URL-freundlicher Slug
  slug        String
  /// Name (z.B. "Defusion: Gedanken-Labeling")
  name        String
  /// Beschreibung (optional, Markdown)
  description String?
  /// Kategorie (z.B. "ACT", "Mindfulness", "CBT")
  category    String?
  /// Skill/F√§higkeit (z.B. "Defusion", "Values Clarification")
  skill       String?
  /// Schritte/Prompts als JSON-Array
  prompts     Json?
  /// Herkunft (SYSTEM, USER)
  origin      TaxonomyOrigin @default(SYSTEM)
  /// Erstellungszeitpunkt
  createdAt   DateTime       @default(now())
  /// Letztes Update
  updatedAt   DateTime       @updatedAt

  user     User?             @relation(fields: [userId], references: [id], onDelete: Cascade)
  sessions ExerciseSession[]

  @@unique([userId, slug])
  @@index([category])
}

/// √úbungs-Durchf√ºhrung: Protokolliert eine einzelne √úbungssitzung.
model ExerciseSession {
  /// Eindeutige ID
  id             String   @id @default(uuid())
  /// Referenz auf die √úbungs-Definition
  definitionId   String
  /// Besitzer-User
  userId         String
  /// Zeitraum (optional)
  timeBoxId      String?
  /// Verlinkter Tagebucheintrag (optional, f√ºr ausf√ºhrliche Notizen)
  journalEntryId String?
  /// Notizen zur Durchf√ºhrung (optional)
  notes          String?
  /// Strukturierte Ergebnisse als JSON (optional)
  results        Json?
  /// Zeitpunkt der Durchf√ºhrung
  occurredAt     DateTime @default(now())
  /// Erstellungszeitpunkt
  createdAt      DateTime @default(now())

  definition   ExerciseDefinition @relation(fields: [definitionId], references: [id])
  user         User               @relation(fields: [userId], references: [id], onDelete: Cascade)
  timeBox      TimeBox?           @relation(fields: [timeBoxId], references: [id])
  journalEntry JournalEntry?      @relation(fields: [journalEntryId], references: [id])

  @@index([userId, occurredAt])
}

// =============================================================================
// TAXONOMIE (Tags, Kategorien, Emotionen, etc.)
// =============================================================================

/// Taxonomie: Einheitliches System f√ºr alle Klassifikationen.
/// Unterst√ºtzt Hierarchie (parentId), verschiedene Arten (kind) und Herkunft (origin).
model Taxonomy {
  /// Eindeutige ID
  id          String         @id @default(uuid())
  /// Besitzer-User
  userId      String
  /// √úbergeordnete Taxonomie (f√ºr Hierarchie, z.B. "Arbeit" ‚Üí "Meetings")
  parentId    String?
  /// URL-freundlicher Slug (eindeutig pro User)
  slug        String
  /// Kurzname f√ºr kompakte Anzeige (z.B. "Meeting")
  shortName   String
  /// Vollst√§ndiger Name (optional, z.B. "Berufliches Meeting")
  longName    String?
  /// Beschreibung (optional)
  description String?
  /// Icon (Emoji oder Icon-Name)
  icon        String?
  /// Bild-URL
  imageUrl    String?
  /// Art (CATEGORY, TAG, EMOTION, TOPIC, TRAIT, LIFE_AREA)
  kind        TaxonomyKind
  /// Herkunft (SYSTEM, USER, IMPORT, AI)
  origin      TaxonomyOrigin @default(USER)
  /// Archiviert? (statt L√∂schen, falls noch verwendet)
  isArchived  Boolean        @default(false)
  /// Sortierreihenfolge in der UI
  sortOrder   Int            @default(0)
  /// Erstellungszeitpunkt
  createdAt   DateTime       @default(now())
  /// Letztes Update
  updatedAt   DateTime       @updatedAt

  user     User       @relation(fields: [userId], references: [id], onDelete: Cascade)
  parent   Taxonomy?  @relation("TaxonomyHierarchy", fields: [parentId], references: [id])
  children Taxonomy[] @relation("TaxonomyHierarchy")
  taggings Tagging[]

  @@unique([userId, slug])
  @@index([userId, kind, isArchived])
  @@index([parentId])
}

/// Tagging: Verkn√ºpft eine Taxonomie mit einer Entit√§t.
/// Polymorph via Entity-Registry (entityId ‚Üí Entity.id).
model Tagging {
  /// Eindeutige ID
  id         String        @id @default(uuid())
  /// Referenz auf die Taxonomie
  taxonomyId String
  /// Referenz auf die getaggte Entit√§t (via Entity-Registry)
  entityId   String
  /// Besitzer-User (f√ºr Multi-Tenant-Queries)
  userId     String
  /// Quelle des Taggings (USER, AI, IMPORT)
  source     TaggingSource @default(USER)
  /// Konfidenz bei AI-Tagging (0.0-1.0)
  confidence Float?
  /// Erstellungszeitpunkt
  createdAt  DateTime      @default(now())

  taxonomy Taxonomy @relation(fields: [taxonomyId], references: [id], onDelete: Cascade)
  entity   Entity   @relation(fields: [entityId], references: [id], onDelete: Cascade)
  user     User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([taxonomyId, entityId])
  @@index([entityId])
  @@index([userId, taxonomyId])
}

// =============================================================================
// PERSONEN & ORTE
// =============================================================================

/// Kontakt: Person aus dem sozialen Umfeld.
model Contact {
  /// Eindeutige ID (= Entity.id)
  id                 String    @id @default(uuid())
  /// Besitzer-User
  userId             String
  /// URL-freundlicher Slug
  slug               String
  /// Vollst√§ndiger Name (Display Name)
  name               String
  /// Vorname (optional)
  givenName          String?
  /// Nachname (optional)
  familyName         String?
  /// Spitzname (optional)
  nickname           String?
  /// Private E-Mail-Adresse (optional)
  emailPrivate       String?
  /// Gesch√§ftliche E-Mail-Adresse (optional)
  emailWork          String?
  /// Private Telefonnummer (optional)
  phonePrivate       String?
  /// Gesch√§ftliche Telefonnummer (optional)
  phoneWork          String?
  /// Private Adresse, formatiert (optional)
  addressHome        String?
  /// Gesch√§ftsadresse, formatiert (optional)
  addressWork        String?
  /// Firma/Arbeitgeber (optional)
  company            String?
  /// Position/Jobtitel (optional)
  jobTitle           String?
  /// Notizen (optional, Markdown)
  notes              String?
  /// Geburtstag (optional)
  birthday           DateTime?
  /// Datum des ersten Treffens (optional)
  firstMetAt         DateTime?
  /// Beziehungsintensit√§t (1-5, optional)
  relationshipLevel  Int?
  /// Archiviert?
  isArchived         Boolean   @default(false)
  /// Favorit?
  isFavorite         Boolean   @default(false)
  /// Prim√§re Website (optional)
  websiteUrl         String?
  /// Social Media URLs als JSON Array [{type, url}]
  socialUrls         Json?
  /// Google People API Resource Name (z.B. "people/c12345")
  googleResourceName String?
  /// Google ETag f√ºr Konflikt-Erkennung
  googleEtag         String?
  /// Profilbild-URL (von Google oder lokal)
  photoUrl           String?
  /// Wohnort (optional)
  locationId         String?
  /// Erstellungszeitpunkt
  createdAt          DateTime  @default(now())
  /// Letztes Update
  updatedAt          DateTime  @updatedAt

  user         User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  location     Location?        @relation(fields: [locationId], references: [id])
  relationsAsA PersonRelation[] @relation("PersonA")
  relationsAsB PersonRelation[] @relation("PersonB")
  interactions Interaction[]
  tasks        Task[]

  @@unique([userId, slug])
  @@unique([userId, googleResourceName])
  @@index([userId, isArchived])
  @@index([userId, isFavorite])
  @@index([locationId])
}

/// Personenbeziehung: Beziehung zwischen zwei Kontakten.
/// Beispiel: "Max ist Bruder von Anna"
model PersonRelation {
  /// Eindeutige ID
  id           String    @id @default(uuid())
  /// Besitzer-User
  userId       String
  /// Person A
  personAId    String
  /// Person B
  personBId    String
  /// Art der Beziehung (z.B. "Bruder", "Kollege", "Ehepartner")
  relationType String
  /// Beziehung g√ºltig ab (optional)
  validFrom    DateTime?
  /// Beziehung g√ºltig bis (optional, NULL = aktuell)
  validTo      DateTime?
  /// Erstellungszeitpunkt
  createdAt    DateTime  @default(now())
  /// Letztes Update
  updatedAt    DateTime  @updatedAt

  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  personA Contact @relation("PersonA", fields: [personAId], references: [id], onDelete: Cascade)
  personB Contact @relation("PersonB", fields: [personBId], references: [id], onDelete: Cascade)

  @@unique([personAId, personBId, relationType])
  @@index([userId])
}

/// Interaktion: Kontakt mit einer Person.
/// Beispiel: Telefonat, Treffen, E-Mail-Austausch, Journal-Erw√§hnung.
model Interaction {
  /// Eindeutige ID
  id             String   @id @default(uuid())
  /// Referenz auf den Kontakt
  contactId      String
  /// Besitzer-User
  userId         String
  /// Zeitraum (optional)
  timeBoxId      String?
  /// Verkn√ºpfter Journal-Eintrag (f√ºr kind=MENTION)
  journalEntryId String?
  /// Art der Interaktion
  kind           InteractionKind @default(GENERAL)
  /// Notizen (optional)
  notes          String?
  /// Zeitpunkt der Interaktion
  occurredAt     DateTime @default(now())
  /// Erstellungszeitpunkt
  createdAt      DateTime @default(now())

  contact      Contact       @relation(fields: [contactId], references: [id], onDelete: Cascade)
  user         User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  timeBox      TimeBox?      @relation(fields: [timeBoxId], references: [id])
  journalEntry JournalEntry? @relation(fields: [journalEntryId], references: [id], onDelete: SetNull)

  @@index([userId, occurredAt])
  @@index([contactId])
  @@index([journalEntryId])
}

/// Ort: Geografischer Ort (Wohnung, Restaurant, Reiseziel, etc.)
model Location {
  /// Eindeutige ID (= Entity.id)
  id         String   @id @default(uuid())
  /// Besitzer-User
  userId     String
  /// URL-freundlicher Slug
  slug       String
  /// Name (z.B. "Zuhause", "Lieblingscaf√©")
  name       String
  /// Breitengrad (optional)
  lat        Float?
  /// L√§ngengrad (optional)
  lng        Float?
  /// Adresse (optional)
  address    String?
  /// Land (optional)
  country    String?
  /// Stadt (optional)
  city       String?
  /// POI-Typ
  poiType    PoiType?
  /// Favorit?
  isFavorite Boolean  @default(false)
  /// Notizen (optional)
  notes      String?
  /// Erstellungszeitpunkt
  createdAt  DateTime @default(now())
  /// Letztes Update
  updatedAt  DateTime @updatedAt

  user           User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  journalEntries JournalEntry[]
  contacts       Contact[]
  visits         LocationVisit[]

  @@unique([userId, slug])
  @@index([userId, isFavorite])
}

/// Ortsbesuch: Verkn√ºpft einen Ort mit einem Zeitraum und optional einem JournalEntry.
/// Erm√∂glicht M:N-Beziehung zwischen Locations und TimeBoxes/JournalEntries.
model LocationVisit {
  /// Eindeutige ID
  id             String    @id @default(uuid())
  /// Besitzer-User
  userId         String
  /// Besuchter Ort
  locationId     String
  /// Zeitraum (Tag/Woche/Monat/Custom)
  timeBoxId      String
  /// Optional: Verkn√ºpfter JournalEntry
  journalEntryId String?
  /// Ankunftszeit (optional)
  arrivedAt      DateTime?
  /// Abfahrtszeit (optional)
  departedAt     DateTime?
  /// Notizen zum Besuch (optional)
  notes          String?
  /// Erstellungszeitpunkt
  createdAt      DateTime  @default(now())

  user         User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  location     Location      @relation(fields: [locationId], references: [id], onDelete: Cascade)
  timeBox      TimeBox       @relation(fields: [timeBoxId], references: [id], onDelete: Cascade)
  journalEntry JournalEntry? @relation(fields: [journalEntryId], references: [id], onDelete: SetNull)

  @@index([userId, timeBoxId])
  @@index([locationId])
  @@index([journalEntryId])
}

// =============================================================================
// AUFGABEN & BENACHRICHTIGUNGEN
// =============================================================================

/// Aufgabe: Todo-Item, optional verkn√ºpft mit Kontakt oder Entity.
model Task {
  /// Eindeutige ID
  id          String     @id @default(uuid())
  /// Besitzer-User
  userId      String
  /// Optionale Verkn√ºpfung mit Entity (via Entity-Registry)
  entityId    String?
  /// Optionale Verkn√ºpfung mit Kontakt
  contactId   String?
  /// Titel der Aufgabe
  title       String
  /// Beschreibung (optional)
  description String?
  /// F√§lligkeitsdatum (optional)
  dueDate     DateTime?
  /// Status der Aufgabe
  status      TaskStatus @default(PENDING)
  /// Erledigungszeitpunkt
  completedAt DateTime?
  /// Erstellungszeitpunkt
  createdAt   DateTime   @default(now())
  /// Letztes Update
  updatedAt   DateTime   @updatedAt

  user    User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  contact Contact? @relation(fields: [contactId], references: [id], onDelete: Cascade)

  @@index([userId, status])
  @@index([contactId])
  @@index([dueDate])
}

/// Benachrichtigung: Systemnachricht an den Benutzer.
model Notification {
  /// Eindeutige ID
  id         String           @id @default(uuid())
  /// Besitzer-User
  userId     String
  /// Typ der Benachrichtigung
  type       NotificationType @default(GENERAL)
  /// Titel
  title      String
  /// Nachricht (optional)
  message    String?
  /// Zus√§tzliche Daten als JSON (typ-spezifisch)
  data       Json?
  /// Gelesen?
  isRead     Boolean          @default(false)
  /// Archivierungszeitpunkt (NULL = nicht archiviert)
  archivedAt DateTime?
  /// Erstellungszeitpunkt
  createdAt  DateTime         @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, archivedAt])
  @@index([userId, isRead])
}

// =============================================================================
// MEDIEN
// =============================================================================

/// Medien-Asset: Einzelne Mediendatei (Foto, Audio, Video).
/// Kann lokal gespeichert oder extern verlinkt sein (Photoprism, etc.).
model MediaAsset {
  /// Eindeutige ID (= Entity.id)
  id               String    @id @default(uuid())
  /// Besitzer-User
  userId           String
  /// Lokaler Dateipfad (z.B. "images/2024/12/13/photo.jpg")
  filePath         String?
  /// Thumbnail als Base64-Bytes (f√ºr schnelle Vorschau)
  thumbnailData    Bytes?
  /// MIME-Type (z.B. "image/jpeg", "audio/mpeg")
  mimeType         String
  /// Breite in Pixeln (f√ºr Bilder/Videos)
  width            Int?
  /// H√∂he in Pixeln (f√ºr Bilder/Videos)
  height           Int?
  /// Dauer in Sekunden (f√ºr Audio/Video)
  duration         Float?
  /// Externer Provider (z.B. "photoprism", "samsung_gallery")
  externalProvider String?
  /// Externe ID beim Provider
  externalId       String?
  /// Externe URL (vollst√§ndige URL zur Datei beim Provider)
  externalUrl      String?
  /// Externe Thumbnail-URL
  thumbnailUrl     String?
  /// Aufnahmezeitpunkt (aus EXIF, optional)
  capturedAt       DateTime?
  /// Erstellungszeitpunkt (Import-Zeitpunkt)
  createdAt        DateTime  @default(now())
  /// Letztes Update
  updatedAt        DateTime  @updatedAt

  user        User              @relation(fields: [userId], references: [id], onDelete: Cascade)
  attachments MediaAttachment[]

  @@unique([userId, filePath])
  @@unique([userId, externalProvider, externalId])
  @@index([userId, capturedAt])
}

/// Medien-Anhang: Verkn√ºpft ein MediaAsset mit einer Entit√§t.
/// Polymorph via Entity-Registry (entityId ‚Üí Entity.id).
/// Erm√∂glicht M:N zwischen Assets und Entit√§ten.
model MediaAttachment {
  /// Eindeutige ID
  id           String    @id @default(uuid())
  /// Referenz auf das MediaAsset
  assetId      String
  /// Referenz auf die Entit√§t (via Entity-Registry)
  entityId     String
  /// Besitzer-User (f√ºr Multi-Tenant-Queries)
  userId       String
  /// Rolle des Anhangs (COVER, GALLERY, ATTACHMENT, THUMBNAIL)
  role         MediaRole @default(ATTACHMENT)
  /// Anzeigereihenfolge in Galerien
  displayOrder Int       @default(0)
  /// Zeitraum-Zuordnung (optional, f√ºr explizite Zeit-Verankerung)
  timeBoxId    String?
  /// Erstellungszeitpunkt
  createdAt    DateTime  @default(now())

  asset   MediaAsset @relation(fields: [assetId], references: [id], onDelete: Cascade)
  entity  Entity     @relation(fields: [entityId], references: [id], onDelete: Cascade)
  user    User       @relation(fields: [userId], references: [id], onDelete: Cascade)
  timeBox TimeBox?   @relation(fields: [timeBoxId], references: [id])

  @@unique([assetId, entityId, role])
  @@index([userId, entityId])
  @@index([timeBoxId])
}

// =============================================================================
// MESSWERTE
// =============================================================================

/// Metrik-Definition: Vorlage f√ºr einen Messwert-Typ.
/// Beispiele: "Energie", "Schlafqualit√§t", "Gewicht", "Bristol-Stuhlform"
model MetricDefinition {
  /// Eindeutige ID
  id          String         @id @default(uuid())
  /// User-ID (NULL = System-definierte Metrik)
  userId      String?
  /// Eindeutiger Code (z.B. "symptom_energie", "weight")
  code        String
  /// Anzeigename (z.B. "Energie")
  name        String
  /// Beschreibung (optional)
  description String?
  /// Datentyp (NUMERIC, TEXT, BOOLEAN, SCALE)
  dataType    MetricDataType @default(NUMERIC)
  /// Einheit (z.B. "kg", "bpm")
  unit        String?
  /// Minimalwert (f√ºr Validierung)
  minValue    Float?
  /// Maximalwert (f√ºr Validierung)
  maxValue    Float?
  /// Normal-Minimum (f√ºr Referenzbereich)
  normalMin   Float?
  /// Normal-Maximum (f√ºr Referenzbereich)
  normalMax   Float?
  /// Kategorie (z.B. "health", "mood", "fitness")
  category    String?
  /// Icon
  icon        String?
  /// Sind Messwerte dieser Metrik sensibel?
  isSensitive Boolean        @default(false)
  /// Herkunft (SYSTEM, USER)
  origin      TaxonomyOrigin @default(USER)
  /// Erstellungszeitpunkt
  createdAt   DateTime       @default(now())
  /// Letztes Update
  updatedAt   DateTime       @updatedAt

  user         User?         @relation(fields: [userId], references: [id], onDelete: Cascade)
  measurements Measurement[]

  @@unique([userId, code])
  @@index([category])
}

/// Messung: Einzelner erfasster Messwert.
model Measurement {
  /// Eindeutige ID (= Entity.id)
  id             String            @id @default(uuid())
  /// Referenz auf die Metrik-Definition
  metricId       String
  /// Besitzer-User
  userId         String
  /// Zeitraum (typischerweise DAY-TimeBox)
  timeBoxId      String?
  /// Numerischer Wert (f√ºr dataType=NUMERIC oder SCALE)
  valueNum       Float?
  /// Text-Wert (f√ºr dataType=TEXT)
  valueText      String?
  /// Boolean-Wert (f√ºr dataType=BOOLEAN)
  valueBool      Boolean?
  /// Verschl√ºsselter Wert (f√ºr sensitive Daten mit ALE)
  valueEncrypted String?
  /// Quelle (MANUAL, IMPORT, DEVICE)
  source         MeasurementSource @default(MANUAL)
  /// Notizen (optional)
  notes          String?
  /// Ist dieser Messwert sensibel?
  isSensitive    Boolean           @default(false)
  /// Zeitpunkt der Messung
  occurredAt     DateTime          @default(now())
  /// Erstellungszeitpunkt
  createdAt      DateTime          @default(now())
  /// Letztes Update
  updatedAt      DateTime          @updatedAt

  metric  MetricDefinition @relation(fields: [metricId], references: [id])
  user    User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  timeBox TimeBox?         @relation(fields: [timeBoxId], references: [id])

  @@index([userId, metricId, occurredAt])
  @@index([timeBoxId])
}

// =============================================================================
// EXTERNE INTEGRATIONEN
// =============================================================================

/// Sync-Provider: Konfiguration einer externen Datenquelle.
model SyncProvider {
  /// Eindeutige ID
  id                   String           @id @default(uuid())
  /// Besitzer-User
  userId               String
  /// Provider-Typ (PHOTOPRISM, TOGGL, etc.)
  provider             SyncProviderType
  /// Verschl√ºsselte Zugangsdaten (API-Key, Token, etc.)
  credentialsEncrypted String?
  /// Provider-spezifische Einstellungen als JSON
  settings             Json?
  /// Sync-Token f√ºr inkrementelle Synchronisation (Google People API)
  syncToken            String?
  /// Ist der Provider aktiv?
  isActive             Boolean          @default(true)
  /// Letzter Sync-Zeitpunkt
  lastSyncAt           DateTime?
  /// Erstellungszeitpunkt
  createdAt            DateTime         @default(now())
  /// Letztes Update
  updatedAt            DateTime         @updatedAt

  user          User           @relation(fields: [userId], references: [id], onDelete: Cascade)
  syncRuns      SyncRun[]
  externalSyncs ExternalSync[]

  @@unique([userId, provider])
  @@index([userId, isActive])
}

/// Sync-Lauf: Protokolliert einen einzelnen Synchronisations-Durchlauf.
model SyncRun {
  /// Eindeutige ID
  id             String     @id @default(uuid())
  /// Referenz auf den Provider
  providerId     String
  /// Startzeitpunkt
  startedAt      DateTime   @default(now())
  /// Endzeitpunkt
  finishedAt     DateTime?
  /// Status (PENDING, RUNNING, COMPLETED, FAILED)
  status         SyncStatus @default(PENDING)
  /// Anzahl verarbeiteter Items
  itemsProcessed Int        @default(0)
  /// Anzahl neu erstellter Items
  itemsCreated   Int        @default(0)
  /// Anzahl aktualisierter Items
  itemsUpdated   Int        @default(0)
  /// Anzahl √ºbersprungener Items
  itemsSkipped   Int        @default(0)
  /// Fehler als JSON-Array (optional)
  errors         Json?

  provider SyncProvider @relation(fields: [providerId], references: [id], onDelete: Cascade)

  @@index([providerId, startedAt])
}

/// External-Sync: Verkn√ºpft eine lokale Entit√§t mit einem externen Objekt.
/// Erm√∂glicht Tracking von Sync-Status und Deduplizierung.
model ExternalSync {
  /// Eindeutige ID
  id           String   @id @default(uuid())
  /// Referenz auf den Provider
  providerId   String
  /// Referenz auf die lokale Entit√§t (via Entity-Registry)
  entityId     String
  /// Besitzer-User (f√ºr Multi-Tenant-Queries)
  userId       String
  /// ID beim externen Provider
  externalId   String
  /// URL beim externen Provider (optional)
  externalUrl  String?
  /// Letzte Sync-Payload als JSON (f√ºr √Ñnderungserkennung)
  syncPayload  Json?
  /// Letzter Sync-Zeitpunkt
  lastSyncedAt DateTime @default(now())
  /// Erstellungszeitpunkt
  createdAt    DateTime @default(now())

  provider SyncProvider @relation(fields: [providerId], references: [id], onDelete: Cascade)
  entity   Entity       @relation(fields: [entityId], references: [id], onDelete: Cascade)
  user     User         @relation(fields: [userId], references: [id], onDelete: Cascade)

  timeTrackingEntries TimeTrackingEntry[]
  calendarEvents      CalendarEvent[]

  @@unique([providerId, externalId])
  @@index([entityId])
  @@index([userId])
}

/// Zeiterfassungs-Eintrag: Erfasste Arbeitszeit (z.B. von Toggl).
model TimeTrackingEntry {
  /// Eindeutige ID (= Entity.id)
  id             String    @id @default(uuid())
  /// Besitzer-User
  userId         String
  /// Referenz auf ExternalSync (falls importiert)
  externalSyncId String?
  /// Zeitraum (optional)
  timeBoxId      String?
  /// Projekt (optional)
  project        String?
  /// Task/Aufgabe (optional)
  task           String?
  /// Beschreibung (optional)
  description    String?
  /// Startzeitpunkt
  startedAt      DateTime
  /// Endzeitpunkt
  endedAt        DateTime?
  /// Dauer in Minuten (berechnet oder explizit)
  duration       Int?
  /// Erstellungszeitpunkt
  createdAt      DateTime  @default(now())
  /// Letztes Update
  updatedAt      DateTime  @updatedAt

  user         User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  externalSync ExternalSync? @relation(fields: [externalSyncId], references: [id])
  timeBox      TimeBox?      @relation(fields: [timeBoxId], references: [id])

  @@index([userId, startedAt])
}

/// Kalender-Event: Termin aus externem Kalender.
model CalendarEvent {
  /// Eindeutige ID (= Entity.id)
  id             String    @id @default(uuid())
  /// Besitzer-User
  userId         String
  /// Referenz auf ExternalSync (falls importiert)
  externalSyncId String?
  /// Zeitraum (optional)
  timeBoxId      String?
  /// Titel
  title          String
  /// Beschreibung (optional)
  description    String?
  /// Startzeitpunkt
  startedAt      DateTime
  /// Endzeitpunkt
  endedAt        DateTime?
  /// Ganzt√§gig?
  isAllDay       Boolean   @default(false)
  /// Ort (optional)
  location       String?
  /// Erstellungszeitpunkt
  createdAt      DateTime  @default(now())
  /// Letztes Update
  updatedAt      DateTime  @updatedAt

  user         User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  externalSync ExternalSync? @relation(fields: [externalSyncId], references: [id])
  timeBox      TimeBox?      @relation(fields: [timeBoxId], references: [id])

  @@index([userId, startedAt])
}

/// Medienkonsum: Gelesene B√ºcher, geh√∂rte Musik, geschaute Filme, etc.
model Consumption {
  /// Eindeutige ID (= Entity.id)
  id         String          @id @default(uuid())
  /// Besitzer-User
  userId     String
  /// Art (MUSIC, MOVIE, BOOK, etc.)
  kind       ConsumptionKind
  /// Titel
  title      String
  /// K√ºnstler/Autor (optional)
  artist     String?
  /// Externe ID (z.B. Spotify Track ID, ISBN)
  externalId String?
  /// Zeitraum (optional)
  timeBoxId  String?
  /// Zeitpunkt des Konsums
  occurredAt DateTime        @default(now())
  /// Erstellungszeitpunkt
  createdAt  DateTime        @default(now())
  /// Letztes Update
  updatedAt  DateTime        @updatedAt

  user    User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  timeBox TimeBox? @relation(fields: [timeBoxId], references: [id])

  @@index([userId, kind, occurredAt])
}

// =============================================================================
// SONSTIGES
// =============================================================================

/// Inventar-Gegenstand: Besitz erfassen (f√ºr Minimalismus, Versicherung, etc.)
model InventoryItem {
  /// Eindeutige ID (= Entity.id)
  id            String          @id @default(uuid())
  /// Besitzer-User
  userId        String
  /// Name des Gegenstands
  name          String
  /// Beschreibung (optional)
  description   String?
  /// Kategorie (z.B. "Elektronik", "Kleidung", "B√ºcher")
  category      String?
  /// Kaufdatum (optional)
  purchaseDate  DateTime?
  /// Kaufpreis (optional)
  purchasePrice Float?
  /// Herkunft/Quelle (z.B. "Amazon", "Geschenk von Oma")
  source        String?
  /// Status (IN_POSSESSION, SOLD, GIFTED)
  status        InventoryStatus @default(IN_POSSESSION)
  /// Foto des Gegenstands (MediaAsset-ID)
  photoAssetId  String?
  /// Erstellungszeitpunkt
  createdAt     DateTime        @default(now())
  /// Letztes Update
  updatedAt     DateTime        @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, status])
  @@index([category])
}

/// Lesezeichen: Gespeicherter Link.
model Bookmark {
  /// Eindeutige ID (= Entity.id)
  id          String   @id @default(uuid())
  /// Besitzer-User
  userId      String
  /// URL
  url         String
  /// Titel
  title       String
  /// Beschreibung (optional)
  description String?
  /// Favicon-URL (optional)
  faviconUrl  String?
  /// Erstellungszeitpunkt
  createdAt   DateTime @default(now())
  /// Letztes Update
  updatedAt   DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, createdAt])
}

/// Entity-Link: Verkn√ºpfung zwischen zwei Entit√§ten.
/// Erm√∂glicht beliebige Querverbindungen (z.B. "erw√§hnt in", "bezieht sich auf").
model EntityLink {
  /// Eindeutige ID
  id        String   @id @default(uuid())
  /// Quell-Entit√§t (via Entity-Registry)
  sourceId  String
  /// Ziel-Entit√§t (via Entity-Registry)
  targetId  String
  /// Besitzer-User
  userId    String
  /// Art der Verkn√ºpfung (z.B. "mentions", "relates_to", "derives_from")
  linkKind  String?
  /// Erstellungszeitpunkt
  createdAt DateTime @default(now())

  source Entity @relation("EntityLinkSource", fields: [sourceId], references: [id], onDelete: Cascade)
  target Entity @relation("EntityLinkTarget", fields: [targetId], references: [id], onDelete: Cascade)
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([sourceId, targetId, linkKind])
  @@index([userId])
  @@index([targetId])
}

/// Embedding: Vektor-Embedding f√ºr semantische Suche (RAG).
model Embedding {
  /// Eindeutige ID
  id          String   @id @default(uuid())
  /// Referenz auf die Entit√§t (via Entity-Registry)
  entityId    String
  /// Besitzer-User
  userId      String
  /// ID des verwendeten Embedding-Modells (z.B. "text-embedding-3-small")
  modelId     String
  /// Chunk-Index (falls Inhalt in mehrere Chunks aufgeteilt)
  chunkIndex  Int      @default(0)
  /// Vektor als Bytes (z.B. float32[1536] serialisiert)
  vector      Bytes
  /// Hash des Quell-Inhalts (f√ºr √Ñnderungserkennung)
  contentHash String?
  /// Erstellungszeitpunkt
  createdAt   DateTime @default(now())

  entity Entity @relation(fields: [entityId], references: [id], onDelete: Cascade)
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([entityId, modelId, chunkIndex])
  @@index([userId, modelId])
}

/// Papierkorb: JSON-Snapshot gel√∂schter Entit√§ten.
/// Erm√∂glicht Wiederherstellung innerhalb von 30 Tagen.
/// WICHTIG: Sensitive Daten werden NICHT im Papierkorb gespeichert!
model Trash {
  /// Eindeutige ID
  id            String   @id @default(uuid())
  /// Besitzer-User
  userId        String
  /// Typ der gel√∂schten Entit√§t (als String, nicht Enum)
  entityType    String
  /// Original-ID der gel√∂schten Entit√§t
  entityId      String
  /// Titel/Name f√ºr Anzeige im Papierkorb
  entityTitle   String?
  /// Vollst√§ndiger Snapshot als JSON
  entityData    Json
  /// Schema-Version zum Zeitpunkt der L√∂schung (f√ºr sp√§tere Migration)
  schemaVersion Int      @default(1)
  /// L√∂schzeitpunkt
  deletedAt     DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, deletedAt])
  @@index([entityType])
}

// =============================================================================
// KI-ASSISTENTEN
// =============================================================================

/// Verbesserungsanweisung: Template f√ºr Textverbesserungen.
/// Speichert benutzerdefinierte Prompts f√ºr die KI-Textverbesserung.
model ImprovementPrompt {
  /// Eindeutige ID
  id        String   @id @default(uuid())
  /// Besitzer-User
  userId    String
  /// Name der Anweisung (z.B. "Grammatik & Struktur")
  name      String
  /// Anweisungstext (Prompt f√ºr die KI)
  prompt    String
  /// Ist dies ein System-Prompt? (kann nicht gel√∂scht werden)
  isSystem  Boolean  @default(false)
  /// Sortierreihenfolge
  sortOrder Int      @default(0)
  /// Erstellungszeitpunkt
  createdAt DateTime @default(now())
  /// Letztes Update
  updatedAt DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, sortOrder])
}

/// Chat-Methode: Benutzerdefinierter KI-Chatbot.
/// √Ñhnlich zu Custom GPTs bei ChatGPT.
model ChatMethod {
  /// Eindeutige ID
  id           String   @id @default(uuid())
  /// Besitzer-User
  userId       String
  /// Name des Chatbots (z.B. "Tagebuch-Coach")
  name         String
  /// Beschreibung (optional)
  description  String?
  /// System-Prompt (definiert Verhalten und Pers√∂nlichkeit)
  systemPrompt String
  /// Icon (Emoji oder Icon-Name)
  icon         String?
  /// Bild-URL f√ºr Avatar
  imageUrl     String?
  /// Erstellungszeitpunkt
  createdAt    DateTime @default(now())
  /// Letztes Update
  updatedAt    DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

/// LLM-Modell: Benutzerspezifische KI-Modell-Konfiguration.
/// Speichert verf√ºgbare LLM-Modelle pro Benutzer mit Provider-Informationen.
model LlmModel {
  /// Eindeutige ID
  id                      String   @id @default(uuid())
  /// Besitzer-User
  userId                  String
  /// Modell-ID beim Provider (z.B. "gpt-4o", "meta-llama/Llama-3.3-70B-Instruct-Turbo")
  modelId                 String
  /// Anzeigename (z.B. "GPT-4o", "Llama-3.3-70B")
  name                    String
  /// Provider: "openai" oder "togetherai"
  provider                String
  /// Eingabekosten pro 1M Tokens (z.B. "$0.15")
  inputCost               String?
  /// Ausgabekosten pro 1M Tokens (z.B. "$0.60")
  outputCost              String?
  /// URL zur Modell-Dokumentation
  url                     String?
  /// Beschreibung, wof√ºr sich das Modell besonders eignet
  bestFor                 String?
  /// Unterst√ºtzt das Modell reasoning_effort Parameter? (f√ºr OpenAI GPT-5 Serie)
  supportsReasoningEffort Boolean  @default(false)
  /// Standard reasoning_effort Wert ("minimal", "low", "medium", "high")
  defaultReasoningEffort  String?
  /// Sortierreihenfolge
  sortOrder               Int      @default(0)
  /// Erstellungszeitpunkt
  createdAt               DateTime @default(now())
  /// Letztes Update
  updatedAt               DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  /// Pro User nur ein Eintrag pro modelId
  @@unique([userId, modelId])
  @@index([userId, sortOrder])
}
